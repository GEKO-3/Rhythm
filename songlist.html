<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Songs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <!-- Preload critical fonts -->
  <link rel="preload" href="Fonts/Montserrat-VariableFont_wght.ttf" as="font" type="font/truetype" crossorigin>
  
  <!-- Local font definitions -->
  <style>
    @font-face {
      font-family: 'Faruma';
      src: url('Fonts/Faruma.ttf') format('truetype');
      font-display: swap;
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Montserrat';
      src: url('Fonts/Montserrat-VariableFont_wght.ttf') format('truetype');
      font-display: swap;
      font-weight: 100 900;
      font-style: normal;
    }
  </style>
  <!-- Favicon and web app manifest -->
  <link rel="icon" type="image/svg+xml" href="favicons/favicon.svg">
  <link rel="icon" type="image/x-icon" href="favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="192x192" href="favicons/icons-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="favicons/icons-512.png">
  <link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-touch-icon.png">
  <link rel="manifest" href="favicons/songlist-manifest.webmanifest">
  
  <!-- Additional meta tags for better SEO and social sharing -->
  <meta name="theme-color" content="#f5d000">
  <meta property="og:title" content="Rhythm Boduberu - Song List">
  <meta property="og:description" content="Browse our collection of traditional Maldivian Boduberu songs">
  <meta property="og:image" content="https://rhythmboduberu.com/src/Logo.png">
  <meta property="og:url" content="https://rhythmboduberu.com/songlist">
  <meta property="og:type" content="website">

  <!-- Web App Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Rhythm Songs">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Rhythm Songs">
  <!-- Optimized CSS Variables and Base Styles -->
  <style>
    :root {
      --primary-color: #f5d000;
      --hover-color: #fced98;
      --active-color: #E6B800;
      --text-color: #2b2b2b;
      --bg-color: #1f1f1f;
      --card-bg: rgba(43, 43, 43, 0.7);
      --border-color: #444;
      --error-color: #ff6b6b;
      --font-family: 'Montserrat', 'SF-Pro', Arial, sans-serif;
      --border-radius: 5px;
      --transition: all 0.2s ease;
      --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Reset and base styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      touch-action: pan-x pan-y;
      overscroll-behavior: none;
      margin: 0;
      padding: 0;
    }

    input, textarea, select, button {
      touch-action: manipulation;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideIn {
      from { transform: translateY(10px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }

    body {
      font-family: var(--font-family);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background-color: var(--bg-color);
      color: var(--primary-color);
      animation: fadeIn 0.5s ease-in-out;
    }

    .container {
      text-align: center;
      position: relative;
      max-width: 600px;
      width: 100%; 
      padding: 10px;
      background: transparent;
      transition: var(--transition);
      animation: slideIn 0.5s ease-in-out;
      margin-bottom: 40px;
    }

    /* Header and search styles */
    .header-search-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: transparent;
      padding: 10px;
      padding-top: max(10px, env(safe-area-inset-top, 0));
      padding-left: max(10px, env(safe-area-inset-left, 0));
      padding-right: max(10px, env(safe-area-inset-right, 0));
    }
    
    .header-search-wrapper::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: transparent;
      pointer-events: none;
    }
    
    .offline-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--error-color);
      color: white;
      text-align: center;
      padding: 5px;
      font-size: 0.9em;
      z-index: 200;
      display: none;
      font-family: var(--font-family);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    
    .offline-indicator.show {
      display: block;
      transform: translateY(0);
    }

    .search-container {
      background: transparent;
      max-width: 600px;
      border-radius: var(--border-radius);
      padding: 5px 10px;
      margin: 0 auto;
      width: 95%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      z-index: 101;
      gap: 10px;
    }

    /* Search and filter components */
    .filter-dropdown {
      position: relative;
      display: inline-block;
    }

    .filter-btn {
      background: var(--primary-color);
      color: var(--text-color);
      border: none;
      border-radius: var(--border-radius);
      padding: 10px;
      font-size: 1.2em;
      cursor: pointer;
      font-family: var(--font-family);
      transition: var(--transition);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .filter-btn:hover {
      background: var(--hover-color);
      transform: scale(1.05);
    }

    .filter-content {
      display: none;
      position: absolute;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      z-index: 1000;
      min-width: 200px;
      top: 100%;
      right: 0;
      margin-top: 2px;
      backdrop-filter: blur(10px);
    }

    .filter-content a {
      color: var(--primary-color);
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      cursor: pointer;
      font-family: var(--font-family);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: var(--transition);
    }

    .filter-content a:last-child {
      border-bottom: none;
    }

    .filter-content a:hover {
      background: var(--hover-color);
      color: var(--text-color);
    }

    .filter-content a.active {
      background: var(--primary-color);
      color: var(--text-color);
      font-weight: 600;
    }

    .filter-content.show {
      display: block;
      animation: fadeIn 0.2s ease;
    }

    #search-box {
      flex: 1;
      padding: 10px 12px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      font-size: 1em;
      background: #222;
      color: var(--primary-color);
      outline: none;
      transition: var(--transition);
      font-family: var(--font-family);
    }

    #search-box::placeholder {
      color: #999;
    }

    #search-box:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(245, 208, 0, 0.2);
    }

    /* Song list styles */
    ul#song-list {
      list-style: none;
      padding: 0;
      margin: 0;
      margin-top: calc(max(env(safe-area-inset-top, 0px), 0px) + 85px);
      /* Optimize for smooth scrolling and rendering */
      will-change: scroll-position;
      -webkit-overflow-scrolling: touch;
      transform: translateZ(0); /* Force hardware acceleration */
      contain: layout style; /* Optimize reflow performance */
    }

    ul#song-list li {
      cursor: pointer;
      padding: 12px 16px;
      border-radius: var(--border-radius);
      transition: var(--transition);
      color: var(--primary-color);
      margin-bottom: 8px;
      font-size: 1.1em;
      background: var(--card-bg);
      font-family: var(--font-family);
      border: 1px solid transparent;
      backdrop-filter: blur(10px);
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      /* Optimize for smooth rendering during scroll */
      will-change: transform, background-color;
      transform: translateZ(0); /* Force hardware acceleration */
      contain: layout; /* Optimize reflow performance */
    }

    ul#song-list li:hover {
      background: var(--hover-color);
      color: var(--text-color);
      font-weight: 600;
      transform: translateY(-1px);
      box-shadow: var(--shadow);
      border-color: var(--primary-color);
    }

    ul#song-list li:active {
      transform: translateY(0);
      background: var(--active-color);
      color: var(--text-color);
    }
    
    /* Ensure clicked state doesn't persist */
    ul#song-list li:focus {
      outline: none;
      background: var(--card-bg);
      color: var(--primary-color);
      transform: none;
    }
    
    /* PIN Entry Styles */
    .pin-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-color);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      backdrop-filter: blur(10px);
    }
    
    .pin-container {
      background: var(--card-bg);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      border: 2px solid var(--border-color);
      max-width: 300px;
      width: 85%;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    
    .pin-title {
      color: var(--primary-color);
      font-size: 1.3em;
      margin-bottom: 25px;
      font-family: var(--font-family);
      font-weight: 600;
    }
    
    .pin-inputs {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .pin-digit {
      width: 50px;
      height: 50px;
      padding: 0;
      font-size: 1.5em;
      text-align: center;
      border: 2px solid var(--border-color);
      border-radius: var(--border-radius);
      background: #222;
      color: var(--primary-color);
      outline: none;
      font-family: var(--font-family);
      transition: var(--transition);
      caret-color: transparent;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: textfield;
    }
    
    .pin-digit:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(245, 208, 0, 0.2);
      transform: scale(1.05);
    }
    
    .pin-digit.filled {
      background: rgba(245, 208, 0, 0.1);
      border-color: var(--primary-color);
    }
    
    .pin-digit.error {
      border-color: var(--error-color);
      animation: shake 0.5s;
    }
    
    .pin-error {
      color: var(--error-color);
      font-size: 0.85em;
      margin-top: 5px;
      min-height: 18px;
      font-family: var(--font-family);
    }
    
    .pin-overlay.hidden {
      display: none;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes spin-and-scale {
      from { transform: rotate(0deg) scale(1); }
      to { transform: rotate(360deg) scale(1); }
    }

    @keyframes spin-and-scale-smooth {
      0% { transform: rotate(0deg); width: 80px; height: 80px; }
      25% { transform: rotate(90deg); width: 200px; height: 200px; }
      50% { transform: rotate(180deg); width: 800px; height: 800px; }
      75% { transform: rotate(270deg); width: 2400px; height: 2400px; }
      100% { transform: rotate(360deg); width: 4000px; height: 4000px; }
    }

    @keyframes slideLeft {
      0% { transform: translateX(0) translateZ(0); }
      100% { transform: translateX(-100vw) translateZ(0); }
    }

    @keyframes slideRight {
      0% { transform: translateX(-100vw) translateZ(0); }
      100% { transform: translateX(0) translateZ(0); }
    }

    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #2b2b2b;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      transition: opacity 0.2s ease-out;
      opacity: 0;
      visibility: hidden;
    }
    
    .loading-screen:not(.fade-out) {
      opacity: 1 !important;
      visibility: visible !important;
      transition: none !important; /* No transition when showing */
    }

    .loading-screen.fade-out {
      opacity: 0;
      pointer-events: none;
      visibility: hidden;
    }

    .loading-logo {
      width: 80px;
      height: 80px;
      animation: spin-and-scale 3s linear infinite;
      transition: none;
      position: relative;
      z-index: 2;
    }

    .loading-logo.fade-out {
      opacity: 0;
      transition: opacity 0.4s ease-out;
    }

    .loading-screen.fade-out .loading-logo {
      animation: spin-and-scale-smooth 1.5s ease-out infinite;
    }

    .loading-progress {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      color: var(--primary-color);
      font-family: var(--font-family);
      font-size: 1em;
      font-weight: 500;
      text-align: center;
      z-index: 3;
      opacity: 0.8;
      transition: opacity 0.3s ease;
    }

    .loading-progress.fade-out {
      opacity: 0;
    }

    /* Pattern Container */
    .pattern-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 1;
      opacity: 0.25;
      transition: opacity 0.6s ease-out;
      will-change: opacity;
      transform: translateZ(0);
    }

    .pattern-container.fade-out {
      opacity: 0;
    }

    .pattern-line {
      position: absolute;
      height: 40px;
      width: 300vw;
      background-image: url('src/repeatp.svg');
      background-repeat: repeat-x;
      background-size: auto 40px;
      left: -100vw;
      will-change: transform;
      transform: translateZ(0);
    }

    .pattern-line:nth-child(odd) {
      animation: slideLeft 10s linear infinite;
    }

    .pattern-line:nth-child(even) {
      animation: slideRight 10s linear infinite;
    }
    
    /* Loading spinner */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(245, 208, 0, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
    }
    
    /* Mobile responsive adjustments */
    @media (max-width: 700px) {
      .search-container {
        gap: 8px;
      }
      
      .filter-btn {
        width: 35px;
        height: 35px;
        font-size: 1.1em;
        padding: 8px;
      }
      
      #search-box {
        padding: 8px 10px;
        font-size: 1em;
      }
      
      ul#song-list {
        margin-top: calc(max(env(safe-area-inset-top, 0px), 0px) + 75px);
      }
      
      ul#song-list li {
        padding: 10px 12px;
        font-size: 1em;
      }
      
      .filter-content {
        right: 0;
        left: auto;
        min-width: 180px;
        max-width: calc(100vw - 20px);
      }
    }
    
    @media (max-width: 400px) {
      .pin-container {
        padding: 20px;
        max-width: 90%;
      }
      
      .pin-digit {
        width: 45px;
        height: 45px;
        font-size: 1.3em;
      }
      
      .pin-inputs {
        gap: 8px;
      }
    }

    /* Dark mode and reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Print styles */
    @media print {
      .pin-overlay, .header-search-wrapper, .filter-dropdown {
        display: none !important;
      }
      
      ul#song-list {
        margin-top: 0;
      }
      
      ul#song-list li {
        background: white !important;
        color: black !important;
        border: 1px solid #ccc !important;
      }
    }
  </style>
  <!-- Optimized JavaScript for better performance and security -->
  <script>
    // Performance and security optimizations
    (function() {
      'use strict';
      
      // Optimized zoom prevention with passive listeners where possible
      const preventZoom = {
        init() {
          document.addEventListener('keydown', this.handleKeydown.bind(this));
          document.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
          document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });
          document.addEventListener('gesturestart', this.preventDefault, { passive: false });
          document.addEventListener('gesturechange', this.preventDefault, { passive: false });
          document.addEventListener('gestureend', this.preventDefault, { passive: false });
        },
        
        handleKeydown(e) {
          if ((e.ctrlKey || e.metaKey) && ['+', '-', '=', '0'].includes(e.key)) {
            e.preventDefault();
          }
        },
        
        handleWheel(e) {
          if (e.ctrlKey) e.preventDefault();
        },
        
        handleTouchEnd(e) {
          const now = Date.now();
          if (now - this.lastTouchEnd <= 350) {
            e.preventDefault();
          }
          this.lastTouchEnd = now;
        },
        
        preventDefault(e) {
          e.preventDefault();
        },
        
        lastTouchEnd: 0
      };

      // Initialize zoom prevention
      preventZoom.init();

      // Optimized Service Worker registration with error handling
      if ('serviceWorker' in navigator && 'caches' in window) {
        window.addEventListener('load', async () => {
          try {
            const registration = await navigator.serviceWorker.register('/sw.js');
            console.log('ServiceWorker registered successfully');
            
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  if (confirm('New content available. Refresh to update?')) {
                    window.location.reload();
                  }
                }
              });
            });
          } catch (error) {
            console.warn('ServiceWorker registration failed:', error);
          }
          
          updateOfflineStatus();
        });
      }
      
      // Optimized online/offline status handling
      window.addEventListener('online', updateOfflineStatus);
      window.addEventListener('offline', updateOfflineStatus);
      
      function updateOfflineStatus() {
        const indicator = document.getElementById('offline-indicator');
        if (indicator) {
          indicator.classList.toggle('show', !navigator.onLine);
        }
      }
    })();
  </script>
</head>
<body>
  <!-- Loading Screen -->
  <div class="loading-screen" id="loading-screen">
    <!-- Animated Pattern Background -->
    <div class="pattern-container" id="pattern-container">
      <!-- Pattern lines will be generated by JavaScript -->
    </div>
    <img src="src/Logo_1.svg" alt="Rhythm Boduberu Loading" class="loading-logo">
    <div class="loading-progress" id="loading-progress">Loading Songs...</div>
  </div>

  <div class="pin-overlay" id="pin-overlay">
    <div class="pin-container">
      <h2 class="pin-title">Enter PIN</h2>
      <div class="pin-inputs">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
      </div>
      <div class="pin-error" id="pin-error"></div>
    </div>
  </div>
  
  <div class="offline-indicator" id="offline-indicator">
    You're offline - Using cached content
  </div>
  <div class="container">
    <div class="header-search-wrapper">
      <div class="search-container">
        <input type="text" id="search-box" placeholder="Search songs..." />
        <div class="filter-dropdown">
          <button class="filter-btn" id="filter-btn">
            <img src="src/Filter.png" alt="Filter" style="width: 20px; height: 20px;">
          </button>
          <div class="filter-content" id="filter-content">
            <!-- Content will be generated dynamically -->
          </div>
        </div>
      </div>
    </div>
    <ul id="song-list"></ul>
  </div>
  <script src="lyrics-showlist-config.js"></script>
  <script src="rhythm-session-manager.js"></script>
  <script src="rhythm-data-service.js"></script>
  <script src="rhythm-page-transition.js"></script>
  <script>
    // Optimized Application Module using Shared Services
    const RhythmSongList = (function() {
      'use strict';
      
      // Configuration and State
      const CONFIG = {
        PIN_AUTH: 'ODc2NQ==',
        MAX_ATTEMPTS: 5,
        LOCKOUT_DURATION: 60 * 60 * 1000, // 1 hour
        SESSION_TIMEOUT: 15 * 60 * 1000, // 15 minutes
        SEARCH_DEBOUNCE: 300,
        CSV_ENDPOINTS: {
          get songs() { return window.RhythmLyricsShowConfig?.lyricsSheet || 'fallback_url'; },
          get showlist() { return window.RhythmLyricsShowConfig?.showListSheet || 'fallback_url'; },
          get cancel() { return window.RhythmLyricsShowConfig?.cancelSheet || 'fallback_url'; }
        }
      };

      const STATE = {
        songs: [],
        currentShowList: [],
        currentGenreFilter: 'all',
        searchDebounceTimer: null,
        isLoadingData: false,
        isInitialized: false,
        searchTimeout: null,
        attemptCount: 0,
        pinAuthenticated: false
      };

      // DOM Elements Cache
      const ELEMENTS = {};

      // Utility Functions
      const Utils = {
        debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },

        async fetchWithRetry(url, options = {}, retries = 3) {
          for (let i = 0; i < retries; i++) {
            try {
              const response = await fetch(url, options);
              if (!response.ok) throw new Error(`HTTP ${response.status}`);
              return response;
            } catch (error) {
              if (i === retries - 1) throw error;
              await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
            }
          }
        },

        parseCSV(csvText) {
          const rows = [];
          let currentRow = [];
          let currentField = '';
          let inQuotes = false;
          let i = 0;
          
          while (i < csvText.length) {
            const char = csvText[i];
            const nextChar = i + 1 < csvText.length ? csvText[i + 1] : null;
            
            if (char === '"') {
              if (inQuotes && nextChar === '"') {
                currentField += '"';
                i += 2;
              } else {
                inQuotes = !inQuotes;
                i++;
              }
            } else if (char === ',' && !inQuotes) {
              currentRow.push(currentField.trim());
              currentField = '';
              i++;
            } else if ((char === '\n' || char === '\r') && !inQuotes) {
              if (currentField || currentRow.length > 0) {
                currentRow.push(currentField.trim());
                if (currentRow.length > 0) {
                  rows.push(currentRow);
                }
                currentRow = [];
                currentField = '';
              }
              if (char === '\r' && nextChar === '\n') {
                i += 2;
              } else {
                i++;
              }
            } else {
              currentField += char;
              i++;
            }
          }
          
          if (currentField || currentRow.length > 0) {
            currentRow.push(currentField.trim());
            if (currentRow.length > 0) {
              rows.push(currentRow);
            }
          }
          
          return rows;
        }
      };

      // PIN Security Module
      const PinSecurity = {
        decodePinConfig(encoded) {
          try {
            const decoded = atob(encoded);
            return decoded.split('').reverse().join('').split('').map(Number);
          } catch (e) {
            return [8, 7, 6, 5]; // Fallback PIN
          }
        },

        validatePinStructure(pin) {
          const actualPin = this.decodePinConfig(CONFIG.PIN_AUTH);
          const checksum = pin.reduce((sum, digit) => sum + digit, 0);
          const expectedChecksum = actualPin.reduce((sum, digit) => sum + digit, 0);
          return checksum === expectedChecksum;
        },

        init() {
          this.setupElements();
          this.setupEventListeners();
          this.checkPinStatus();
        },

        setupElements() {
          ELEMENTS.pinOverlay = document.getElementById('pin-overlay');
          ELEMENTS.pinDigits = [...document.querySelectorAll('.pin-digit')];
          ELEMENTS.pinError = document.getElementById('pin-error');
        },

        setupEventListeners() {
          ELEMENTS.pinDigits.forEach((digit, index) => {
            digit.addEventListener('input', (e) => this.handleDigitInput(e, index));
            digit.addEventListener('keydown', (e) => this.handleDigitKeydown(e, index));
            digit.addEventListener('paste', this.handlePaste.bind(this));
          });
        },

        checkPinStatus() {
          // Check lockout status
          const lockoutEnd = localStorage.getItem('pinLockoutEnd');
          if (lockoutEnd && Date.now() < parseInt(lockoutEnd)) {
            this.startLockout();
            LoadingScreen.hide();
            return;
          }

          // Clear expired lockout
          if (lockoutEnd && Date.now() >= parseInt(lockoutEnd)) {
            localStorage.removeItem('pinLockoutEnd');
            localStorage.removeItem('pinAttemptCount');
          }

          // Restore attempt count
          const savedAttempts = localStorage.getItem('pinAttemptCount');
          if (savedAttempts) {
            STATE.attemptCount = parseInt(savedAttempts);
          }

          // Check existing session
          const sessionData = sessionStorage.getItem('pinSession');
          if (sessionData) {
            try {
              const session = JSON.parse(sessionData);
              const sessionAge = Date.now() - session.timestamp;
              
              // Be more lenient with existing sessions - only expire if much older
              if (session.authenticated && sessionAge < (CONFIG.SESSION_TIMEOUT * 3)) {
                STATE.pinAuthenticated = true;
                this.hidePinOverlay();
                DataManager.loadSongsData();
                SessionManager.refreshSession(); // Refresh instead of starting timeout
                return;
              }
            } catch (e) {
              sessionStorage.removeItem('pinSession');
            }
          }

          // Show PIN overlay and hide loading screen
          LoadingScreen.hide();
          ELEMENTS.pinOverlay.classList.remove('hidden');
          setTimeout(() => ELEMENTS.pinDigits[0].focus(), 300);
        },

        handleDigitInput(e, index) {
          if (e.target.disabled) return;
          
          const value = e.target.value;
          
          if (!/^\d$/.test(value)) {
            e.target.value = '';
            return;
          }

          this.clearPinError();
          e.target.classList.add('filled');
          
          if (index < 3) {
            ELEMENTS.pinDigits[index + 1].focus();
          } else {
            this.verifyPin();
          }
        },

        handleDigitKeydown(e, index) {
          if (e.target.disabled) return;
          
          if (e.key === 'Backspace') {
            e.target.value = '';
            e.target.classList.remove('filled');
            if (index > 0) {
              ELEMENTS.pinDigits[index - 1].focus();
            }
          }
          
          if (e.key === 'Enter') {
            this.verifyPin();
          }
          
          if (e.key === 'ArrowLeft' && index > 0) {
            ELEMENTS.pinDigits[index - 1].focus();
          }
          if (e.key === 'ArrowRight' && index < 3) {
            ELEMENTS.pinDigits[index + 1].focus();
          }
        },

        handlePaste(e) {
          e.preventDefault();
          const pasteData = e.clipboardData.getData('text');
          
          if (/^\d{4}$/.test(pasteData)) {
            ELEMENTS.pinDigits.forEach((digit, index) => {
              digit.value = pasteData[index];
              digit.classList.add('filled');
            });
            this.verifyPin();
          }
        },

        verifyPin() {
          const enteredPin = ELEMENTS.pinDigits.map(digit => digit.value).join('');
          
          if (enteredPin.length !== 4) {
            this.showPinError('Please enter all 4 digits');
            return;
          }

          const lockoutEnd = localStorage.getItem('pinLockoutEnd');
          if (lockoutEnd && Date.now() < parseInt(lockoutEnd)) {
            this.showPinError('Account locked. Please wait.');
            return;
          }

          const enteredPinArray = enteredPin.split('').map(Number);
          const actualPinConfig = this.decodePinConfig(CONFIG.PIN_AUTH);
          
          const basicMatch = enteredPinArray.every((digit, index) => 
            digit === actualPinConfig[index]
          );
          
          const structureValid = this.validatePinStructure(enteredPinArray);
          
          if (basicMatch && structureValid) {
            STATE.pinAuthenticated = true;
            STATE.attemptCount = 0;
            localStorage.removeItem('pinAttemptCount');
            
            const sessionData = {
              timestamp: Date.now(),
              authenticated: true,
              sessionType: 'songlist'
            };
            sessionStorage.setItem('pinSession', JSON.stringify(sessionData));
            
            this.hidePinOverlay();
            App.loadData(); // Use App.loadData instead of DataManager.loadSongsData
          } else {
            STATE.attemptCount++;
            localStorage.setItem('pinAttemptCount', STATE.attemptCount.toString());
            
            if (STATE.attemptCount >= CONFIG.MAX_ATTEMPTS) {
              this.startLockout();
            } else {
              const remaining = CONFIG.MAX_ATTEMPTS - STATE.attemptCount;
              this.showPinError(`Incorrect PIN. ${remaining} attempts remaining.`);
              this.clearPinInputs();
              setTimeout(() => ELEMENTS.pinDigits[0].focus(), 1000);
            }
          }
        },

        startLockout() {
          const lockoutEnd = Date.now() + CONFIG.LOCKOUT_DURATION;
          localStorage.setItem('pinLockoutEnd', lockoutEnd.toString());
          localStorage.setItem('pinAttemptCount', STATE.attemptCount.toString());
          
          ELEMENTS.pinDigits.forEach(digit => digit.disabled = true);
          this.startLockoutTimer(lockoutEnd);
        },

        startLockoutTimer(lockoutEnd) {
          const updateDisplay = () => {
            const timeLeft = lockoutEnd - Date.now();
            if (timeLeft <= 0) {
              clearInterval(STATE.lockoutTimer);
              localStorage.removeItem('pinLockoutEnd');
              localStorage.removeItem('pinAttemptCount');
              STATE.attemptCount = 0;
              
              ELEMENTS.pinDigits.forEach(digit => {
                digit.disabled = false;
                digit.value = '';
                digit.classList.remove('filled');
              });
              
              this.showPinError('Lockout expired. You may try again.');
              setTimeout(() => {
                this.clearPinError();
                ELEMENTS.pinDigits[0].focus();
              }, 2000);
              return;
            }
            
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            this.showPinError(`Too many attempts. Try again in ${minutes}:${seconds.toString().padStart(2, '0')}`);
          };
          
          updateDisplay();
          STATE.lockoutTimer = setInterval(updateDisplay, 1000);
        },

        showPinError(message) {
          ELEMENTS.pinError.textContent = message;
          ELEMENTS.pinDigits.forEach(digit => digit.classList.add('error'));
          setTimeout(() => {
            ELEMENTS.pinDigits.forEach(digit => digit.classList.remove('error'));
          }, 500);
        },

        clearPinError() {
          ELEMENTS.pinError.textContent = '';
          ELEMENTS.pinDigits.forEach(digit => digit.classList.remove('error'));
        },

        clearPinInputs() {
          ELEMENTS.pinDigits.forEach(digit => {
            digit.value = '';
            digit.classList.remove('filled');
          });
        },

        hidePinOverlay() {
          ELEMENTS.pinOverlay.classList.add('hidden');
        }
      };
      // Session Management Module
      const SessionManager = {
        init() {
          this.setupVisibilityTracking();
          this.setupActivityTracking();
        },

        setupVisibilityTracking() {
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
              STATE.isPageVisible = true;
              this.updateLastActivity();
              // Don't expire session when page becomes visible - just refresh the session
              if (STATE.pinAuthenticated) {
                this.refreshSession();
              }
            } else {
              STATE.isPageVisible = false;
              // Only start timeout when page becomes hidden
              if (STATE.pinAuthenticated) {
                this.startBackgroundTimeout();
              }
            }
          });

          window.addEventListener('focus', () => {
            STATE.isPageVisible = true;
            this.updateLastActivity();
            if (STATE.pinAuthenticated) {
              this.clearSessionTimeout();
              this.refreshSession();
            }
          });
          
          window.addEventListener('blur', () => {
            // Don't clear session immediately on blur, only start timeout
            if (STATE.pinAuthenticated) {
              this.startBackgroundTimeout();
            }
          });
        },

        setupActivityTracking() {
          const activityEvents = ['click', 'keydown', 'scroll', 'touchstart', 'mousemove'];
          activityEvents.forEach(event => {
            document.addEventListener(event, () => this.updateLastActivity(), true);
          });
        },

        updateLastActivity() {
          STATE.lastActivityTime = Date.now();
          if (STATE.pinAuthenticated) {
            this.refreshSession();
            // Clear any existing timeout since user is active
            this.clearSessionTimeout();
          }
        },

        refreshSession() {
          // Update session storage to keep it fresh
          const sessionData = {
            timestamp: Date.now(),
            authenticated: true,
            sessionType: 'songlist'
          };
          sessionStorage.setItem('pinSession', JSON.stringify(sessionData));
        },

        startBackgroundTimeout() {
          // Only start timeout when page is not visible/focused
          this.clearSessionTimeout();
          STATE.sessionTimer = setTimeout(() => {
            // Only expire if page is still not visible
            if (!STATE.isPageVisible || document.visibilityState === 'hidden') {
              this.expireSession();
            }
          }, CONFIG.SESSION_TIMEOUT);
        },

        startSessionTimeout() {
          // Legacy method - now just refreshes session if page is visible
          if (STATE.isPageVisible && document.visibilityState === 'visible') {
            this.refreshSession();
          } else {
            this.startBackgroundTimeout();
          }
        },

        clearSessionTimeout() {
          if (STATE.sessionTimer) {
            clearTimeout(STATE.sessionTimer);
            STATE.sessionTimer = null;
          }
        },

        expireSession() {
          // Only expire if page is actually hidden/not focused
          if (STATE.isPageVisible && document.visibilityState === 'visible') {
            console.log('Skipping session expiry - page is visible');
            return;
          }

          STATE.pinAuthenticated = false;
          sessionStorage.removeItem('pinSession');
          this.clearSessionTimeout();
          
          LoadingScreen.hide();
          ELEMENTS.pinOverlay.classList.remove('hidden');
          // Session expired - will be handled by shared session manager events
        }
      };

      // Loading Screen Module
      const LoadingScreen = {
        init() {
          this.setupElements();
          this.generatePatternLines();
          this.setupResizeHandler();
        },

        setupElements() {
          ELEMENTS.loadingScreen = document.getElementById('loading-screen');
          ELEMENTS.patternContainer = document.getElementById('pattern-container');
          ELEMENTS.loadingLogo = document.querySelector('.loading-logo');
          ELEMENTS.loadingProgress = document.querySelector('.loading-progress');
        },

        generatePatternLines() {
          if (!ELEMENTS.patternContainer) return;
          
          try {
            const viewportHeight = window.innerHeight;
            const lineHeight = 40;
            const numberOfLines = Math.ceil(viewportHeight / lineHeight) + 1;
            
            ELEMENTS.patternContainer.innerHTML = '';
            
            for (let i = 0; i < numberOfLines; i++) {
              const line = document.createElement('div');
              line.className = 'pattern-line';
              line.style.top = (i * lineHeight) + 'px';
              line.style.willChange = 'transform';
              line.style.transform = 'translateZ(0)';
              ELEMENTS.patternContainer.appendChild(line);
            }
          } catch (error) {
            console.warn('Failed to generate pattern lines:', error);
            // Continue without pattern if it fails
          }
        },

        setupResizeHandler() {
          window.addEventListener('resize', () => {
            this.generatePatternLines();
          });
        },

        show(text = 'Loading Songs...') {
          if (ELEMENTS.loadingScreen) {
            // Clear any pending hide timeouts
            this.clearHideTimeouts();
            
            // Set navigation mode if this is a lyrics loading request
            if (text.includes('lyrics') || text.includes('Lyrics')) {
              this.navigationMode = true;
            } else {
              this.navigationMode = false;
            }
            
            ELEMENTS.loadingScreen.classList.remove('fade-out');
            ELEMENTS.loadingScreen.style.display = 'flex';
            ELEMENTS.loadingScreen.style.opacity = '1';
            ELEMENTS.loadingScreen.style.visibility = 'visible';
            ELEMENTS.loadingScreen.style.pointerEvents = 'auto';
            ELEMENTS.loadingScreen.style.transition = 'none';
            
            // Reset any fade-out classes
            if (ELEMENTS.loadingLogo) {
              ELEMENTS.loadingLogo.classList.remove('fade-out');
            }
            if (ELEMENTS.loadingProgress) {
              ELEMENTS.loadingProgress.classList.remove('fade-out');
              ELEMENTS.loadingProgress.textContent = text;
            }
            if (ELEMENTS.patternContainer) {
              ELEMENTS.patternContainer.classList.remove('fade-out');
            }
          }
        },

        clearHideTimeouts() {
          if (this.hideTimeout1) {
            clearTimeout(this.hideTimeout1);
            this.hideTimeout1 = null;
          }
          if (this.hideTimeout2) {
            clearTimeout(this.hideTimeout2);
            this.hideTimeout2 = null;
          }
          if (this.hideTimeout3) {
            clearTimeout(this.hideTimeout3);
            this.hideTimeout3 = null;
          }
        },

        hide() {
          if (!ELEMENTS.loadingScreen) return;
          
          // Check if loading screen is in navigation mode (should not be hidden by songlist)
          if (this.navigationMode) {
            console.log('ðŸ›¡ï¸ Loading screen in navigation mode - ignoring hide request');
            return;
          }

          console.log('â¬‡ï¸ Hiding loading screen');
          
          // Clear any existing timeouts first
          this.clearHideTimeouts();

          // Start enlarging animation
          ELEMENTS.loadingScreen.classList.add('fade-out');
          ELEMENTS.loadingScreen.style.transition = 'none';
          ELEMENTS.loadingScreen.style.opacity = '1';

          // Start fade out after a brief delay
          this.hideTimeout1 = setTimeout(() => {
            ELEMENTS.loadingScreen.style.transition = 'opacity 0.6s ease-out';
            
            // Fade out logo and text
            if (ELEMENTS.loadingLogo) {
              ELEMENTS.loadingLogo.classList.add('fade-out');
            }
            if (ELEMENTS.loadingProgress) {
              ELEMENTS.loadingProgress.classList.add('fade-out');
            }
            
            // Fade out pattern container
            if (ELEMENTS.patternContainer) {
              ELEMENTS.patternContainer.classList.add('fade-out');
            }
            
            // Fade out background
            this.hideTimeout2 = setTimeout(() => {
              ELEMENTS.loadingScreen.style.opacity = '0';
            }, 200);
            
            // Hide the loading screen completely
            this.hideTimeout3 = setTimeout(() => {
              ELEMENTS.loadingScreen.style.display = 'none';
              ELEMENTS.loadingScreen.classList.remove('fade-out');
              if (ELEMENTS.loadingLogo) {
                ELEMENTS.loadingLogo.classList.remove('fade-out');
              }
              if (ELEMENTS.loadingProgress) {
                ELEMENTS.loadingProgress.classList.remove('fade-out');
              }
              if (ELEMENTS.patternContainer) {
                ELEMENTS.patternContainer.classList.remove('fade-out');
              }
              
              // Clear timeout references and navigation mode
              this.hideTimeout1 = null;
              this.hideTimeout2 = null;
              this.hideTimeout3 = null;
              this.navigationMode = false;
            }, 1000);
          }, 200);
        },
        
        forceHide() {
          // Force hide even in navigation mode (for lyrics page completion)
          this.navigationMode = false;
          this.hide();
        }
      };

      // Data Management Module
      const DataManager = {
        async loadSongsData() {
          if (!STATE.pinAuthenticated) {
            console.warn('PIN not authenticated - blocking song data load');
            return;
          }

          // Show loading screen
          LoadingScreen.show('Loading Songs...');

          try {
            const [csvSongs] = await Promise.all([
              this.getSongsFromCSV(),
              this.loadLatestShowlist()
            ]);
            
            STATE.songs = csvSongs;
            window.songs = csvSongs; // Global compatibility
            
            // Show completion message before hiding
            LoadingScreen.show('Songs loaded successfully!');
            
            // Small delay to ensure smooth loading animation
            setTimeout(() => {
              LoadingScreen.hide();
              UI.initializeSongList();
            }, 800);
          } catch (error) {
            console.error('Failed to load songs data:', error);
            STATE.songs = [];
            window.songs = [];
            STATE.currentShowList = [];
            
            LoadingScreen.show('Loading complete');
            setTimeout(() => {
              LoadingScreen.hide();
              UI.initializeSongList();
            }, 500);
          }
        },

        async getSongsFromCSV() {
          try {
            LoadingScreen.show('Fetching songs data...');
            const response = await Utils.fetchWithRetry(CONFIG.CSV_ENDPOINTS.songs);
            const csvText = await response.text();
            
            LoadingScreen.show('Processing songs...');
            
            // Cache for offline use
            if ('caches' in window) {
              const cache = await caches.open('rhythm-csv-data');
              await cache.put('csv-songs-data', new Response(csvText, {
                headers: { 'Content-Type': 'text/csv' }
              }));
            }
            
            return this.processCSVData(csvText);
          } catch (error) {
            console.error('Error fetching CSV:', error);
            LoadingScreen.show('Loading from cache...');
            return this.loadFromCache();
          }
        },

        async loadFromCache() {
          if ('caches' in window) {
            try {
              const cache = await caches.open('rhythm-csv-data');
              const cachedResponse = await cache.match('csv-songs-data');
              
              if (cachedResponse) {
                const csvText = await cachedResponse.text();
                return this.processCSVData(csvText);
              }
            } catch (error) {
              console.error('Error loading from cache:', error);
            }
          }
          return [];
        },

        processCSVData(csvText) {
          const rows = Utils.parseCSV(csvText);
          const songMap = new Map();
          
          for (let i = 1; i < rows.length; i++) {
            const columns = rows[i];
            if (columns.length >= 5) {
              const [timestamp, idStr, name, genre, lyrics] = columns.map(col => col.trim());
              const id = parseInt(idStr, 10);
              
              if (!isNaN(id) && name && genre && lyrics) {
                const song = { id, timestamp, name, genre, lyrics };
                
                if (!songMap.has(id) || new Date(timestamp) > new Date(songMap.get(id).timestamp)) {
                  songMap.set(id, song);
                }
              }
            }
          }
          
          return Array.from(songMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        },

        async loadLatestShowlist() {
          try {
            LoadingScreen.show('Loading show list...');
            const [showlistResponse, cancelResponse] = await Promise.all([
              Utils.fetchWithRetry(CONFIG.CSV_ENDPOINTS.showlist),
              Utils.fetchWithRetry(CONFIG.CSV_ENDPOINTS.cancel)
            ]);
            
            const [showlistCsv, cancelCsv] = await Promise.all([
              showlistResponse.text(),
              cancelResponse.text()
            ]);
            
            const showlistRows = Utils.parseCSV(showlistCsv);
            const cancelRows = Utils.parseCSV(cancelCsv);
            
            if (showlistRows.length <= 1) {
              STATE.currentShowList = [];
              return;
            }
            
            const latestRow = showlistRows[showlistRows.length - 1];
            const [, latestUID, latestShowList] = latestRow.map(col => col.trim());
            
            const isCancelled = cancelRows.some(row => 
              row[1] === latestUID && row[2] && row[2].toLowerCase() === 'yes'
            );
            
            if (!isCancelled && latestShowList) {
              STATE.currentShowList = latestShowList.split('\n')
                .map(song => song.trim())
                .filter(song => song);
              window.currentShowList = STATE.currentShowList; // Global compatibility
            } else {
              STATE.currentShowList = [];
              if (STATE.currentGenreFilter === 'showlist') {
                STATE.currentGenreFilter = 'all';
                localStorage.setItem('songListFilter', STATE.currentGenreFilter);
              }
            }
          } catch (error) {
            console.error('Failed to load latest showlist:', error);
            STATE.currentShowList = [];
            if (STATE.currentGenreFilter === 'showlist') {
              STATE.currentGenreFilter = 'all';
              localStorage.setItem('songListFilter', STATE.currentGenreFilter);
            }
          }
        }
      };
      // UI Management Module
      const UI = {
        init() {
          this.cacheElements();
          this.setupEventListeners();
        },

        cacheElements() {
          ELEMENTS.songList = document.getElementById('song-list');
          ELEMENTS.searchBox = document.getElementById('search-box');
          ELEMENTS.filterBtn = document.getElementById('filter-btn');
          ELEMENTS.filterDropdown = document.querySelector('.filter-dropdown');
          ELEMENTS.filterContent = document.getElementById('filter-content');
          
          // Cache loading screen elements for immediate access
          this.loadingScreenElement = document.getElementById('loading-screen');
          this.loadingProgressElement = document.getElementById('loading-progress');
        },

        setupEventListeners() {
          // Filter dropdown
          ELEMENTS.filterBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            ELEMENTS.filterContent.classList.toggle('show');
          });
          
          // Close dropdown when clicking outside
          document.addEventListener('click', () => {
            ELEMENTS.filterContent.classList.remove('show');
          });
          
          // Prevent dropdown from closing when clicking inside
          ELEMENTS.filterContent.addEventListener('click', (e) => {
            e.stopPropagation();
          });
          
          // Optimized search with debouncing
          const debouncedSearch = Utils.debounce((value) => {
            this.renderList(value, STATE.currentGenreFilter);
          }, CONFIG.SEARCH_DEBOUNCE);
          
          ELEMENTS.searchBox.addEventListener('input', (e) => {
            debouncedSearch(e.target.value);
          });
          
          // Auto-focus search box when typing
          document.addEventListener('keydown', (e) => {
            if (e.target.tagName !== 'INPUT' && e.key.match(/[a-zA-Z0-9]/)) {
              ELEMENTS.searchBox.focus();
            }
          });
        },

        initializeSongList() {
          // Restore saved filter state
          const savedFilter = localStorage.getItem('songListFilter');
          if (savedFilter) {
            STATE.currentGenreFilter = savedFilter;
          }
          
          this.updateFilterDropdown();
          this.renderList('', STATE.currentGenreFilter);
          
          // Set initial filter button state
          const filterBtn = ELEMENTS.filterBtn;
          if (STATE.currentGenreFilter !== 'all') {
            filterBtn.style.background = 'var(--active-color)';
            filterBtn.style.transform = 'scale(1.05)';
          }
          
          // Restore scroll position if returning from lyrics page
          const savedScrollPosition = localStorage.getItem('songListScrollPosition');
          if (savedScrollPosition) {
            setTimeout(() => {
              window.scrollTo(0, parseInt(savedScrollPosition));
              localStorage.removeItem('songListScrollPosition');
            }, 100);
          }
        },

        updateFilterDropdown() {
          if (!STATE.songs || STATE.songs.length === 0) {
            ELEMENTS.filterContent.innerHTML = '<a data-filter="all">All (0)</a>';
            return;
          }
          
          // Count songs by genre
          const genreCounts = {
            all: STATE.songs.length,
            Baburu: 0,
            Kaasi: 0,
            Nala: 0,
            Taki: 0,
            Thinberu: 0,
            Zamaanee: 0,
            showlist: 0
          };
          
          STATE.songs.forEach(song => {
            if (genreCounts.hasOwnProperty(song.genre)) {
              genreCounts[song.genre]++;
            }
          });

          // Count showlist songs
          if (STATE.currentShowList && STATE.currentShowList.length > 0) {
            genreCounts.showlist = STATE.currentShowList.length;
          }
          
          // Build dropdown content with data attributes
          let dropdownContent = `<a data-filter="all" ${STATE.currentGenreFilter === 'all' ? 'class="active"' : ''}>All (${genreCounts.all})</a>`;
          
          // Only add showlist option if there's an active showlist
          if (STATE.currentShowList && STATE.currentShowList.length > 0) {
            dropdownContent += `<a data-filter="showlist" ${STATE.currentGenreFilter === 'showlist' ? 'class="active"' : ''}>Show List (${genreCounts.showlist})</a>`;
          }
          
          dropdownContent += `
            <a data-filter="Baburu" ${STATE.currentGenreFilter === 'Baburu' ? 'class="active"' : ''}>Baburu (${genreCounts.Baburu})</a>
            <a data-filter="Kaasi" ${STATE.currentGenreFilter === 'Kaasi' ? 'class="active"' : ''}>Kaasi (${genreCounts.Kaasi})</a>
            <a data-filter="Nala" ${STATE.currentGenreFilter === 'Nala' ? 'class="active"' : ''}>Nala (${genreCounts.Nala})</a>
            <a data-filter="Taki" ${STATE.currentGenreFilter === 'Taki' ? 'class="active"' : ''}>Taki (${genreCounts.Taki})</a>
            <a data-filter="Thinberu" ${STATE.currentGenreFilter === 'Thinberu' ? 'class="active"' : ''}>Thinberu (${genreCounts.Thinberu})</a>
            <a data-filter="Zamaanee" ${STATE.currentGenreFilter === 'Zamaanee' ? 'class="active"' : ''}>Zamaanee (${genreCounts.Zamaanee})</a>
          `;
          
          ELEMENTS.filterContent.innerHTML = dropdownContent;
          
          // Add click event listeners to filter options
          ELEMENTS.filterContent.querySelectorAll('a[data-filter]').forEach(link => {
            link.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              const filter = e.target.getAttribute('data-filter');
              this.setFilter(filter);
            });
          });
        },

        renderList(searchFilter = '', genreFilter = 'all') {
          ELEMENTS.songList.innerHTML = '';
          
          if (!STATE.songs || STATE.songs.length === 0) {
            this.showMessage('No songs available', '#999');
            return;
          }
          
          // Filter songs with optimized search
          const searchLower = searchFilter.toLowerCase();
          const filteredSongs = STATE.songs
            .filter(song => {
              const matchesSearch = !searchFilter || song.name.toLowerCase().includes(searchLower);
              let matchesGenre;
              
              if (genreFilter === 'showlist') {
                matchesGenre = STATE.currentShowList && STATE.currentShowList.includes(song.name);
              } else {
                matchesGenre = genreFilter === 'all' || song.genre === genreFilter;
              }
              
              return matchesSearch && matchesGenre;
            })
            .sort((a, b) => a.name.localeCompare(b.name));
          
          if (filteredSongs.length === 0) {
            this.showMessage('No songs match your search', '#999');
            return;
          }

          // Render songs with chunked rendering for smooth scrolling
          this.renderSongsChunked(filteredSongs);
        },

        renderSongsChunked(songs) {
          // Clear existing content
          ELEMENTS.songList.innerHTML = '';
          
          // Render in chunks to prevent blocking and ensure smooth scrolling
          const CHUNK_SIZE = 20; // Render 20 songs at a time
          let currentIndex = 0;
          
          const renderChunk = () => {
            const chunk = songs.slice(currentIndex, currentIndex + CHUNK_SIZE);
            const fragment = document.createDocumentFragment();
            
            chunk.forEach(song => {
              const li = this.createSongElement(song);
              fragment.appendChild(li);
            });
            
            ELEMENTS.songList.appendChild(fragment);
            currentIndex += CHUNK_SIZE;
            
            // Continue rendering if there are more songs
            if (currentIndex < songs.length) {
              // Use requestAnimationFrame for smooth rendering
              requestAnimationFrame(renderChunk);
            }
          };
          
          // Start rendering
          renderChunk();
        },

        createSongElement(song) {
          const li = document.createElement('li');
          li.textContent = song.name;
          li.style.color = '#f5d467'; // All songs yellow since CSV doesn't have English lyrics
          li.style.transition = 'all 0.1s ease'; // Smooth transitions for touch feedback
          
          // Touch/scroll tracking for preventing accidental clicks
          let touchStartY = 0;
          let touchStartX = 0;
          let touchStartTime = 0;
          let hasMoved = false;
          let isScrolling = false;
          let scrollDetectionTimeout = null;
          
          li.addEventListener('click', (e) => {
            // Prevent click if user was scrolling
            if (isScrolling || hasMoved) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            
            // Show loading screen IMMEDIATELY - before any other processing
            this.showLoadingScreenImmediate();
            
            // Prevent any default behavior
            e.preventDefault();
            e.stopPropagation();
            
            // Handle the click immediately - no setTimeout needed
            this.handleSongClick(song);
          });
          
          // Add mousedown for even faster response on desktop
          li.addEventListener('mousedown', (e) => {
            // Only show loading for actual clicks, not during scroll
            if (!isScrolling && !hasMoved) {
              this.showLoadingScreenImmediate();
            }
          }, { passive: true });
          
          // Add touch event handlers with improved scroll detection
          li.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            touchStartY = touch.clientY;
            touchStartX = touch.clientX;
            touchStartTime = Date.now();
            hasMoved = false;
            isScrolling = false;
            
            // Clear any existing scroll detection timeout
            if (scrollDetectionTimeout) {
              clearTimeout(scrollDetectionTimeout);
            }
            
            // Visual feedback only - don't trigger loading yet
            li.style.background = 'var(--active-color)';
            li.style.color = 'var(--text-color)';
            li.style.transform = 'scale(0.98)'; // Subtle press effect
          }, { passive: true });
          
          li.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const touchCurrentY = touch.clientY;
            const touchCurrentX = touch.clientX;
            
            const moveDistanceY = Math.abs(touchCurrentY - touchStartY);
            const moveDistanceX = Math.abs(touchCurrentX - touchStartX);
            
            // More sensitive scroll detection - any movement over 5px
            if (moveDistanceY > 5 || moveDistanceX > 5) {
              hasMoved = true;
              
              // If vertical movement is greater, it's likely scrolling
              if (moveDistanceY > moveDistanceX) {
                isScrolling = true;
              }
              
              // Reset visual feedback since this is movement
              li.style.background = '';
              li.style.color = '';
              li.style.transform = ''; // Remove press effect
            }
          }, { passive: true });
          
          li.addEventListener('touchend', (e) => {
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - touchStartTime;
            
            // Set a timeout to reset scrolling state
            scrollDetectionTimeout = setTimeout(() => {
              isScrolling = false;
              hasMoved = false;
            }, 150); // Longer timeout for better scroll detection
            
            // Only handle as click if:
            // 1. Touch was brief (less than 200ms for better responsiveness)
            // 2. User didn't move much
            // 3. Not currently scrolling
            if (!hasMoved && !isScrolling && touchDuration < 200) {
              // Show loading screen for valid tap
              this.showLoadingScreenImmediate();
              
              e.preventDefault();
              this.handleSongClick(song);
            } else {
              // Reset styling for scroll/invalid touch
              setTimeout(() => {
                if (!li.dataset.navigating) {
                  li.style.background = '';
                  li.style.color = '';
                  li.style.transform = ''; // Reset scale
                }
              }, 100);
            }
          }, { passive: false });
          
          li.addEventListener('touchcancel', () => {
            li.style.background = '';
            li.style.color = '';
          }, { passive: true });
          
          return li;
        },

        showLoadingScreenImmediate() {
          console.log('ðŸš€ Showing loading screen immediately');
          
          // Prevent multiple rapid calls
          if (this.loadingShown && !this.allowOverride) {
            console.log('âš ï¸ Loading already shown, ignoring');
            return;
          }
          this.loadingShown = true;
          this.allowOverride = false;
          
          // Use cached loading screen element for maximum speed
          if (!this.loadingScreenElement) {
            this.loadingScreenElement = document.getElementById('loading-screen');
            this.loadingProgressElement = document.getElementById('loading-progress');
          }
          
          // Clear any pending hide operations from LoadingScreen and set navigation mode
          if (window.LoadingScreen && typeof window.LoadingScreen.clearHideTimeouts === 'function') {
            console.log('ðŸ›‘ Clearing LoadingScreen timeouts and setting navigation mode');
            window.LoadingScreen.clearHideTimeouts();
            window.LoadingScreen.navigationMode = true;
          }
          
          // Show loading screen with multiple methods for immediate response
          if (window.LoadingScreen) {
            window.LoadingScreen.show('Loading lyrics...');
          }
          
          // Direct DOM manipulation as immediate fallback
          if (this.loadingScreenElement) {
            this.loadingScreenElement.style.display = 'flex';
            this.loadingScreenElement.style.opacity = '1';
            this.loadingScreenElement.style.visibility = 'visible';
            this.loadingScreenElement.style.pointerEvents = 'auto';
            this.loadingScreenElement.style.transition = 'none';
            this.loadingScreenElement.classList.remove('fade-out');
            
            // Reset any child element fade-out states
            const loadingLogo = this.loadingScreenElement.querySelector('.loading-logo');
            const patternContainer = this.loadingScreenElement.querySelector('#pattern-container');
            
            if (loadingLogo) loadingLogo.classList.remove('fade-out');
            if (patternContainer) patternContainer.classList.remove('fade-out');
            
            if (this.loadingProgressElement) {
              this.loadingProgressElement.textContent = 'Loading lyrics...';
              this.loadingProgressElement.classList.remove('fade-out');
            }
          }
          
          console.log('âœ… Loading screen shown successfully');
          
          // Reset override flag after a short delay
          setTimeout(() => {
            this.allowOverride = true;
          }, 500);
        },

        handleSongClick(song) {
          // Prevent multiple rapid clicks
          if (this.navigating) return;
          this.navigating = true;
          
          // Loading screen should already be visible from immediate show
          // Don't show it again to avoid any delay
          
          // Clear active state immediately for better UX
          this.clearAllActiveSongs();
          
          // Mark this song as navigating to prevent style reset
          const songElements = document.querySelectorAll('ul#song-list li');
          songElements.forEach(el => {
            if (el.textContent.trim() === song.name) {
              el.dataset.navigating = 'true';
            }
          });
          
          // Save current scroll position
          localStorage.setItem('songListScrollPosition', window.pageYOffset || document.documentElement.scrollTop);
          localStorage.setItem('selectedSongId', song.id);
          
          // Use shared page transition service for seamless navigation
          if (window.RhythmPageTransition) {
            window.RhythmPageTransition.navigateToLyrics(song.id);
          } else {
            // Fallback: Refresh session before navigating
            if (window.RhythmSession && window.RhythmSession.isAuthenticated()) {
              window.RhythmSession.refreshSession();
            }
            
            window.location.href = 'lyrics-csv.html';
          }
        },
        
        clearAllActiveSongs() {
          const allSongs = document.querySelectorAll('ul#song-list li');
          allSongs.forEach(songElement => {
            songElement.style.background = '';
            songElement.style.color = '';
            songElement.style.transform = '';
            songElement.classList.remove('active');
            songElement.removeAttribute('data-active');
            songElement.removeAttribute('data-navigating');
          });
        },

        showMessage(message, color = '#999') {
          const li = document.createElement('li');
          li.textContent = message;
          li.style.color = color;
          li.style.cursor = 'default';
          ELEMENTS.songList.appendChild(li);
        },

        setFilter(genre) {
          STATE.currentGenreFilter = genre;
          localStorage.setItem('songListFilter', genre);
          ELEMENTS.filterContent.classList.remove('show');
          this.updateFilterDropdown(); // Update the dropdown to show active state
          this.renderList(ELEMENTS.searchBox.value, STATE.currentGenreFilter);
          
          // Update filter button to show active state
          const filterBtn = ELEMENTS.filterBtn;
          if (genre !== 'all') {
            filterBtn.style.background = 'var(--active-color)';
            filterBtn.style.transform = 'scale(1.05)';
          } else {
            filterBtn.style.background = 'var(--primary-color)';
            filterBtn.style.transform = 'scale(1)';
          }
        }
      };

      // Main Application Object
      const App = {
        async init() {
          document.addEventListener('DOMContentLoaded', async () => {
            try {
              console.log('Starting app initialization...');
              LoadingScreen.init();
              LoadingScreen.show('Initializing...');

              // Initialize basic PIN system first
              PinSecurity.init();
              UI.init();

              STATE.isInitialized = true;
              console.log('App initialization complete');
            } catch (error) {
              console.error('Failed to initialize app:', error);
              LoadingScreen.updateProgress('Initialization failed: ' + error.message);
            }
          });
        },

        async waitForServices() {
          return new Promise((resolve, reject) => {
            console.log('Waiting for shared services...');
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max wait
            
            const checkServices = () => {
              attempts++;
              console.log(`Checking services (attempt ${attempts}):`, {
                RhythmSession: !!window.RhythmSession,
                RhythmData: !!window.RhythmData,
                RhythmPageTransition: !!window.RhythmPageTransition,
                config: !!window.RhythmLyricsShowConfig
              });
              
              if (window.RhythmSession && window.RhythmData && window.RhythmPageTransition) {
                console.log('All services loaded successfully!');
                resolve();
              } else if (attempts >= maxAttempts) {
                console.error('Services failed to load within timeout');
                // Continue anyway for fallback functionality
                resolve();
              } else {
                setTimeout(checkServices, 100);
              }
            };
            checkServices();
          });
        },

        async loadData() {
          try {
            // Check authentication state
            const isAuthenticated = STATE.pinAuthenticated || 
              (window.RhythmSession && window.RhythmSession.isAuthenticated());
            
            if (!isAuthenticated) {
              console.log('Not authenticated, skipping data load');
              LoadingScreen.hide();
              return;
            }

            // Try shared data service first
            if (window.RhythmData) {
              console.log('Using shared data service');
              LoadingScreen.show('Loading songs...');
              
              // Use fast cached data for navigation
              await window.RhythmData.loadSongsData(false, false); // Don't skip loading events for initial load
              const songs = await window.RhythmData.getAllSongs();
              STATE.songs = songs;
              
              UI.renderSongs(STATE.songs);
              UI.showUI();
              LoadingScreen.hide();
            } else {
              // Use DataManager which handles its own loading flow
              console.log('Using DataManager - it will handle the complete loading flow');
              DataManager.loadSongsData();
              // DataManager handles LoadingScreen and UI updates internally
            }
          } catch (error) {
            console.error('Failed to load songs:', error);
            LoadingScreen.updateProgress('Failed to load songs');
            LoadingScreen.hide();
          }
        },

        setFilter(genre) {
          UI.setFilter(genre);
        }
      };

      // Global API for backward compatibility
      window.setFilter = App.setFilter.bind(App);
      window.songs = STATE.songs;
      window.currentShowList = STATE.currentShowList;

      // Initialize the application
      App.init();

      return App;
    })();
  </script>
</body>
</html>
