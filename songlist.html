<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Songs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <!-- Local font definitions -->
  <style>
    @font-face {
      font-family: 'Faruma';
      src: url('Fonts/Faruma.ttf') format('truetype');
      font-display: swap;
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Montserrat';
      src: url('Fonts/Montserrat-VariableFont_wght.ttf') format('truetype');
      font-display: swap;
      font-weight: normal;
      font-style: normal;
    }
  </style>
  
  <!-- Preload critical resources -->
  <link rel="preload" href="Fonts/Montserrat-VariableFont_wght.ttf" as="font" type="font/ttf" crossorigin>
  <link rel="preload" href="src/Filter.png" as="image">
  <!-- Favicon and web app manifest -->
  <link rel="icon" type="image/svg+xml" href="favicons/favicon.svg">
  <link rel="icon" type="image/x-icon" href="favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon.ico">
  <link rel="icon" type="image/png" sizes="192x192" href="favicons/icons-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="favicons/icons-512.png">
  <link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-touch-icon.png">
  <link rel="manifest" href="favicons/songlist-manifest.webmanifest">
  
  <!-- Additional meta tags for better SEO and social sharing -->
  <meta name="theme-color" content="#f5d000">
  <meta property="og:title" content="Rhythm Boduberu - Song List">
  <meta property="og:description" content="Browse our collection of traditional Maldivian Boduberu songs">
  <meta property="og:image" content="https://rhythmboduberu.com/src/Logo.png">
  <meta property="og:url" content="https://rhythmboduberu.com/songlist">
  <meta property="og:type" content="website">

  <!-- Web App Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Rhythm Songs">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Rhythm Songs">
  <style>
    html, body {
      touch-action: pan-x pan-y;
      overscroll-behavior: none;
    }
    input, textarea, select, button {
      touch-action: manipulation;
    }
    :root {
      --primary-color: #f5d000;
      --hover-color: #fced98;
      --active-color: #E6B800;
      --text-color: #2b2b2b;
      --bg-opacity: rgba(31, 31, 31, 0.0);
      --hover-color2: #3a3a3a;
      --active-color2: #111111;
      --border-color: #444;
      --background-dark: #1f1f1f;
      --card-background: rgba(43,43,43,0.7);
      --error-color: #ff6b6b;
      --success-color: #28a745;
    }
    
    * {
      box-sizing: border-box;
    }
    
    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
    
    @keyframes slideIn {
      0% { transform: translateY(10px); opacity: 0; }
      100% { transform: translateY(0); opacity: 1; }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }
    body {
      font-family: 'Montserrat', 'SF-Pro', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: var(--background-dark);
      background-size: cover;
      color: var(--primary-color);
      animation: fadeIn 0.5s ease-in-out;
      will-change: scroll-position;
    }
    .container {
      text-align: center;
      position: relative;
      max-width: 600px;
      width: 100%; 
      padding: 10px;
      background: transparent;
      transition: transform 0.3s ease;
      animation: slideIn 0.5s ease-in-out;
      margin-top: 0;
      margin-bottom: 40px;
    }
    .header-search-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: transparent;
      padding-top: env(safe-area-inset-top, 0);
      padding-left: env(safe-area-inset-left, 0);
      padding-right: env(safe-area-inset-right, 0);
      padding-bottom: 10px;
    }
    
    .header-search-wrapper::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: transparent;
      pointer-events: none;
    }
    
    .offline-indicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #ff6b6b;
      color: white;
      text-align: center;
      padding: 5px;
      font-size: 0.9em;
      z-index: 200;
      display: none;
      font-family: 'Montserrat', 'SF-Pro', Arial, sans-serif;
    }
    
    .offline-indicator.show {
      display: block;
    }
    h1 {
      color: var(--primary-color);
      margin-bottom: 0.5em;
      margin-top: 0.5em;
      font-family: 'Montserrat', 'SF-Pro', Arial, sans-serif;
    }
    .search-container {
      background: transparent;
      max-width: 600px;
      border-radius: 8px;
      padding: 10px 16px;
      margin: 0 auto;
      width: 95%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      z-index: 101;
      gap: 10px;
      margin-top: 10px;
    }
    .filter-dropdown {
      position: relative;
      display: inline-block;
    }
    .filter-btn {
      background: var(--primary-color);
      color: var(--text-color);
      border: none;
      border-radius: 5px;
      padding: 10px;
      font-size: 1.2em;
      cursor: pointer;
      font-family: inherit;
      transition: background-color 0.3s ease, transform 0.2s ease;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .filter-btn:hover {
      background: var(--hover-color);
      transform: scale(1.05);
    }
    
    .filter-btn:active {
      transform: scale(0.95);
    }
    .filter-content {
      display: none;
      position: absolute;
      background: var(--card-background);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      z-index: 1000;
      min-width: 200px;
      top: 100%;
      left: 0;
      margin-top: 5px;
      overflow: hidden;
    }
    
    .filter-content a {
      color: var(--primary-color);
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      cursor: pointer;
      font-family: inherit;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .filter-content a:last-child {
      border-bottom: none;
    }
    
    .filter-content a:hover {
      background: var(--hover-color);
      color: var(--text-color);
      transform: translateX(4px);
    }
    .show {
      display: block;
    }
    #search-box {
      flex: 1;
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      margin-bottom: 0;
      font-size: 1em;
      background: #222;
      color: var(--primary-color);
      outline: none;
      transition: all 0.3s ease;
      margin-top: 0;
      font-family: inherit;
    }
    
    #search-box::placeholder {
      color: #999;
      opacity: 0.7;
    }
    
    #search-box:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(245, 208, 0, 0.2);
      background: #2a2a2a;
    }
    ul#song-list {
      list-style: none;
      padding: 0;
      margin: 0;
      margin-top: calc(env(safe-area-inset-top, 0px) + 105px);
      contain: layout style;
    }
    
    ul#song-list li {
      cursor: pointer;
      padding: 0.7em 0.5em;
      border-bottom: 1px solid #1d1d1d;
      transition: all 0.2s ease;
      color: var(--primary-color);
      border-radius: 5px;
      margin-bottom: 5px;
      font-size: 1.1em;
      background: var(--card-background);
      font-family: inherit;
      will-change: transform, background-color;
      transform: translateZ(0); /* Force GPU acceleration */
    }
    
    ul#song-list li:hover {
      background: var(--hover-color);
      color: var(--text-color);
      font-weight: 600;
      transform: translateY(-1px) translateZ(0);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    ul#song-list li:active {
      transform: translateY(0) translateZ(0);
    }
    
    @media (max-width: 700px) {
      .header-search-wrapper {
        padding: 10px;
      }
      .search-container {
        padding: 5px 10px;
        gap: 8px;
      }
      .filter-btn {
        width: 35px;
        height: 35px;
        font-size: 1.1em;
        padding: 8px;
      }
      #search-box {
        padding: 8px 10px;
        font-size: 1em;
      }
      ul#song-list {
        margin-top: calc(env(safe-area-inset-top, 0px) + 85px);
      }
      ul#song-list li {
        padding: 0.6em 0.4em;
        font-size: 1em;
      }
    }
    
    /* PIN Entry Styles */
    .pin-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background-dark);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      backdrop-filter: blur(5px);
    }
    
    .pin-container {
      background: var(--card-background);
      backdrop-filter: blur(20px);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      border: 2px solid var(--border-color);
      max-width: 300px;
      width: 85%;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    }
    
    .pin-title {
      color: var(--primary-color);
      font-size: 1.3em;
      margin-bottom: 25px;
      font-family: inherit;
      font-weight: 600;
    }
    
    .pin-inputs {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 20px;
    }
    
    .pin-digit {
      width: 50px;
      height: 50px;
      padding: 0;
      font-size: 1.5em;
      text-align: center;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      background: #222;
      color: var(--primary-color);
      outline: none;
      font-family: inherit;
      transition: all 0.3s ease;
      caret-color: transparent;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: textfield;
    }
    
    .pin-digit:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(245, 208, 0, 0.2);
      transform: scale(1.05);
      background: #2a2a2a;
    }
    
    .pin-digit.filled {
      background: rgba(245, 208, 0, 0.1);
      border-color: var(--primary-color);
    }
    
    .pin-digit.error {
      border-color: var(--error-color);
      animation: shake 0.5s ease-in-out;
    }
    
    .pin-error {
      color: var(--error-color);
      font-size: 0.85em;
      margin-top: 5px;
      min-height: 18px;
      font-family: inherit;
      font-weight: 500;
    }
    
    .pin-overlay.hidden {
      display: none;
    }
    
    /* Mobile responsive adjustments */
    @media (max-width: 400px) {
      .pin-container {
        padding: 20px;
        max-width: 90%;
      }
      
      .pin-digit {
        width: 45px;
        height: 45px;
        font-size: 1.3em;
      }
      
      .pin-inputs {
        gap: 8px;
      }
    }
  </style>
  <script>
    // Debounce utility for performance optimization
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Throttle utility for scroll events
    function throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    }

    // Prevent zoom with keyboard (Ctrl/Cmd + +/-/0) and mouse wheel
    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && (
        e.key === '+' || e.key === '-' || e.key === '=' || e.key === '0'
      )) {
        e.preventDefault();
      }
    });
    document.addEventListener('wheel', function(e) {
      if (e.ctrlKey) e.preventDefault();
    }, { passive: false });
    
    // Prevent double-tap zoom on mobile
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 350) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    }, false);
    
    // Prevent pinch-zoom and gesture events on iOS/Safari
    document.addEventListener('gesturestart', function(e) {
      e.preventDefault();
    });
    document.addEventListener('gesturechange', function(e) {
      e.preventDefault();
    });
    document.addEventListener('gestureend', function(e) {
      e.preventDefault();
    });

    // Register service worker for offline functionality
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('/sw.js')
          .then(function(registration) {
            console.log('ServiceWorker registration successful');
            
            // Listen for updates
            registration.addEventListener('updatefound', function() {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', function() {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New content is available
                  if (confirm('New content is available. Refresh to update?')) {
                    window.location.reload();
                  }
                }
              });
            });
          })
          .catch(function(error) {
            console.log('ServiceWorker registration failed: ', error);
          });
        
        updateOfflineStatus();
      });
    }
    
    // Optimized online/offline event handlers
    const updateOfflineStatus = throttle(() => {
      const offlineIndicator = document.getElementById('offline-indicator');
      if (!navigator.onLine) {
        offlineIndicator.classList.add('show');
      } else {
        offlineIndicator.classList.remove('show');
      }
    }, 1000);
    
    // Listen for online/offline events
    window.addEventListener('online', updateOfflineStatus);
    window.addEventListener('offline', updateOfflineStatus);
  </script>
</head>
<body>
  <div class="pin-overlay" id="pin-overlay">
    <div class="pin-container">
      <h2 class="pin-title">Enter PIN</h2>
      <div class="pin-inputs">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
        <input type="tel" class="pin-digit" maxlength="1" pattern="[0-9]" inputmode="numeric">
      </div>
      <div class="pin-error" id="pin-error"></div>
    </div>
  </div>
  
  <div class="offline-indicator" id="offline-indicator">
    You're offline - Using cached content
  </div>
  <div class="container">
    <div class="header-search-wrapper">
      <div class="search-container">
        <input type="text" id="search-box" placeholder="Search songs..." />
        <div class="filter-dropdown">
          <button class="filter-btn" id="filter-btn">
            <img src="src/Filter.png" alt="Filter" style="width: 20px; height: 20px;">
          </button>
          <div class="filter-content" id="filter-content">
            <!-- Content will be generated dynamically -->
          </div>
        </div>
      </div>
    </div>
    <ul id="song-list"></ul>
  </div>
  <script>
    // Global variables
    let songList, searchBox, filterBtn, filterDropdown, filterContent;
    let currentGenreFilter = 'all';
    let songs = []; // Will be populated from CSV
    window.currentShowList = []; // Will be populated from showlist CSV
    
    // ===========================================
    // PIN CONFIGURATION (Easy to change)
    // ===========================================
    const pinAuth = 'ODc2NQ=='; // Change this to update PIN
    
    // PIN Security Functions
    function decodePinConfig(encoded) {
      try {
        const decoded = atob(encoded);
        const reversed = decoded.split('').reverse().join('');
        return reversed.split('').map(Number);
      } catch (e) {
        return [8, 7, 6, 5]; // Fallback PIN
      }
    }
    
    function validatePinStructure(pin) {
      // Additional validation layer
      const checksum = pin.reduce((sum, digit) => sum + digit, 0);
      // Calculate expected checksum based on actual PIN
      const expectedChecksum = actualPinConfig.reduce((sum, digit) => sum + digit, 0);
      return checksum === expectedChecksum;
    }
    
    // Get actual PIN configuration
    const actualPinConfig = decodePinConfig(pinAuth);
    
    // URL deobfuscation helper
    function getUrl(key) {
      const urls = {
        'c1': 'aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvZS8yUEFDWC0xdlNWdTVmOXgyZi11Mmhha0xfMXBaeV9oYmVweHRuRmY3TVJXVzlMekd1OFNDcV95UWl0aFBETUJWd1dKZmdjeEJYOVVlY09SaTNlVmpSZC9wdWI/b3V0cHV0PWNzdg==',
        'c2': 'aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvZS8yUEFDWC0xdlQydTRGdTJmMGJZRl9Ub1BVLWRpZ0QxamJxTnNMN0RPSnBCX2tYbFdUc25YY2dldHN2Y0h1aG5NcXRGLWdDRmlfUG5TaVd6VXdiTjNwNi9wdWI/b3V0cHV0PWNzdg==',
        'c3': 'aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvZS8yUEFDWC0xdlFkS2xDRkRjMUlFUVhFZ2prWDFVTHBHTGpXaXRSemFIOFdzYTFmTkdxR2JYa011U2hUTm1URHNrMWZMNkY4STNEMDIyem4ySFVJckN1eC9wdWI/b3V0cHV0PWNzdg=='
      };
      return atob(urls[key]);
    }
    
    // PIN Protection System
    let pinAuthenticated = false;
    let pinOverlay, pinDigits, pinError;
    let attemptCount = 0;
    const maxAttempts = 5;
    const lockoutDuration = 60 * 60 * 1000; // 1 hour in milliseconds
    let lockoutTimer = null;
    
    // Session timeout system
    const sessionTimeout = 3 * 60 * 1000; // 3 minutes in milliseconds
    let sessionTimer = null;
    let lastActivityTime = Date.now();
    let isPageVisible = true;
    
    // Initialize PIN system on page load
    document.addEventListener('DOMContentLoaded', function() {
      initializePinSystem();
      initializeSessionTimeout();
    });
    
    function initializeSessionTimeout() {
      // Track page visibility
      document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'visible') {
          isPageVisible = true;
          updateLastActivity();
          // Check if session expired while away
          if (pinAuthenticated && Date.now() - lastActivityTime > sessionTimeout) {
            expireSession();
          }
        } else {
          isPageVisible = false;
          clearSessionTimeout();
        }
      });
      
      // Track user activity to reset session timer
      const activityEvents = ['click', 'keydown', 'scroll', 'touchstart', 'mousemove'];
      activityEvents.forEach(event => {
        document.addEventListener(event, updateLastActivity, true);
      });
      
      // For mobile apps, also track window focus/blur
      window.addEventListener('focus', function() {
        updateLastActivity();
      });
      
      window.addEventListener('blur', function() {
        clearSessionTimeout();
      });
    }
    
    function updateLastActivity() {
      lastActivityTime = Date.now();
      if (pinAuthenticated && !isPageVisible) {
        startSessionTimeout();
      }
    }
    
    function startSessionTimeout() {
      clearSessionTimeout(); // Clear any existing timeout
      
      sessionTimer = setTimeout(() => {
        expireSession();
      }, sessionTimeout);
    }
    
    function clearSessionTimeout() {
      if (sessionTimer) {
        clearTimeout(sessionTimer);
        sessionTimer = null;
      }
    }
    
    function expireSession() {
      pinAuthenticated = false;
      sessionStorage.removeItem('pinSession');
      
      // Clear session timeout
      clearSessionTimeout();
      
      // Show PIN overlay again
      pinOverlay.classList.remove('hidden');
      clearPinInputs();
      
      // Focus on first digit when user returns
      setTimeout(() => {
        pinDigits[0].focus();
      }, 300);
      
      // Show session expired message
      showPinError('Session expired. Please enter PIN again.');
      setTimeout(() => {
        clearPinError();
      }, 3000);
    }
    
    function initializePinSystem() {
      pinOverlay = document.getElementById('pin-overlay');
      pinDigits = [
        ...document.querySelectorAll('.pin-digit')
      ];
      pinError = document.getElementById('pin-error');
      
      // Check if PIN was previously entered (but still require re-entry)
      checkPinStatus();
      
      // Setup event listeners for each digit input
      pinDigits.forEach((digit, index) => {
        digit.addEventListener('input', (e) => handleDigitInput(e, index));
        digit.addEventListener('keydown', (e) => handleDigitKeydown(e, index));
        digit.addEventListener('paste', handlePaste);
      });
      
      // Auto-focus first digit with delay for mobile
      setTimeout(() => {
        pinDigits[0].focus();
      }, 500); // Increased delay to ensure DOM is ready
    }
    
    function handleDigitInput(e, index) {
      // Check if locked out
      if (e.target.disabled) return;
      
      const value = e.target.value;
      
      // Only allow single digit numbers
      if (!/^\d$/.test(value)) {
        e.target.value = '';
        return;
      }
      
      // Clear any previous errors
      clearPinError();
      
      // Mark as filled
      e.target.classList.add('filled');
      
      // Move to next digit
      if (index < 3) {
        pinDigits[index + 1].focus();
      } else {
        // Last digit entered, verify PIN
        verifyPin();
      }
    }
    
    function handleDigitKeydown(e, index) {
      // Check if locked out
      if (e.target.disabled) return;
      
      // Handle backspace
      if (e.key === 'Backspace') {
        e.target.value = '';
        e.target.classList.remove('filled');
        if (index > 0) {
          pinDigits[index - 1].focus();
        }
      }
      
      // Handle Enter key
      if (e.key === 'Enter') {
        verifyPin();
      }
      
      // Handle arrow keys
      if (e.key === 'ArrowLeft' && index > 0) {
        pinDigits[index - 1].focus();
      }
      if (e.key === 'ArrowRight' && index < 3) {
        pinDigits[index + 1].focus();
      }
    }
    
    function handlePaste(e) {
      e.preventDefault();
      const pasteData = e.clipboardData.getData('text');
      
      // Check if pasted data is 4 digits
      if (/^\d{4}$/.test(pasteData)) {
        pinDigits.forEach((digit, index) => {
          digit.value = pasteData[index];
          digit.classList.add('filled');
        });
        verifyPin();
      }
    }
    
    function checkPinStatus() {
      // Check if currently locked out
      const lockoutEnd = localStorage.getItem('pinLockoutEnd');
      if (lockoutEnd && Date.now() < parseInt(lockoutEnd)) {
        startLockout();
        return;
      }
      
      // Clear any expired lockout
      if (lockoutEnd && Date.now() >= parseInt(lockoutEnd)) {
        localStorage.removeItem('pinLockoutEnd');
        localStorage.removeItem('pinAttemptCount');
      }
      
      // Restore attempt count if not locked out
      const savedAttempts = localStorage.getItem('pinAttemptCount');
      if (savedAttempts) {
        attemptCount = parseInt(savedAttempts);
      }
      
      // Check for existing valid session
      const sessionData = sessionStorage.getItem('pinSession');
      if (sessionData) {
        try {
          const session = JSON.parse(sessionData);
          const sessionAge = Date.now() - session.timestamp;
          
          if (session.authenticated && sessionAge < sessionTimeout) {
            // Valid session exists
            pinAuthenticated = true;
            hidePinOverlay();
            loadSongsData();
            startSessionTimeout();
            return;
          }
        } catch (e) {
          // Invalid session data
          sessionStorage.removeItem('pinSession');
        }
      }
      
      // No valid session - show PIN overlay
      pinOverlay.classList.remove('hidden');
      
      // Ensure keyboard opens when PIN overlay is shown
      setTimeout(() => {
        pinDigits[0].focus();
      }, 300);
    }
    
    function startLockout() {
      const lockoutEnd = Date.now() + lockoutDuration;
      localStorage.setItem('pinLockoutEnd', lockoutEnd.toString());
      localStorage.setItem('pinAttemptCount', attemptCount.toString());
      
      // Disable all inputs
      pinDigits.forEach(digit => digit.disabled = true);
      
      startLockoutTimer(lockoutEnd);
    }
    
    function startLockoutTimer(lockoutEnd) {
      function updateLockoutDisplay() {
        const timeLeft = lockoutEnd - Date.now();
        if (timeLeft <= 0) {
          // Lockout expired
          clearInterval(lockoutTimer);
          localStorage.removeItem('pinLockoutEnd');
          localStorage.removeItem('pinAttemptCount');
          attemptCount = 0;
          
          // Re-enable inputs
          pinDigits.forEach(digit => {
            digit.disabled = false;
            digit.value = '';
            digit.classList.remove('filled');
          });
          
          showPinError('Lockout expired. You may try again.');
          setTimeout(() => {
            clearPinError();
            pinDigits[0].focus();
          }, 2000);
          return;
        }
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        showPinError(`Too many attempts. Try again in ${minutes}:${seconds.toString().padStart(2, '0')}`);
      }
      
      // Update immediately and then every second
      updateLockoutDisplay();
      lockoutTimer = setInterval(updateLockoutDisplay, 1000);
    }
    
    function verifyPin() {
      const enteredPin = pinDigits.map(digit => digit.value).join('');
      
      if (enteredPin.length !== 4) {
        showPinError('Please enter all 4 digits');
        return;
      }
      
      // Check if currently locked out
      const lockoutEnd = localStorage.getItem('pinLockoutEnd');
      if (lockoutEnd && Date.now() < parseInt(lockoutEnd)) {
        showPinError('Account locked. Please wait.');
        return;
      }
      
      // Convert entered PIN to array for comparison
      const enteredPinArray = enteredPin.split('').map(Number);
      
      // Multi-layer validation
      const basicMatch = enteredPinArray.every((digit, index) => 
        digit === actualPinConfig[index]
      );
      
      const structureValid = validatePinStructure(enteredPinArray);
      
      if (basicMatch && structureValid) {
        // Correct PIN
        pinAuthenticated = true;
        attemptCount = 0;
        localStorage.removeItem('pinAttemptCount');
        
        // Create session
        const sessionData = {
          timestamp: Date.now(),
          authenticated: true,
          sessionType: 'songlist'
        };
        sessionStorage.setItem('pinSession', JSON.stringify(sessionData));
        
        hidePinOverlay();
        loadSongsData();
        startSessionTimeout();
      } else {
        // Incorrect PIN
        attemptCount++;
        localStorage.setItem('pinAttemptCount', attemptCount.toString());
        
        if (attemptCount >= maxAttempts) {
          startLockout();
        } else {
          const remainingAttempts = maxAttempts - attemptCount;
          showPinError(`Incorrect PIN. ${remainingAttempts} attempts remaining.`);
          clearPinInputs();
          setTimeout(() => {
            pinDigits[0].focus();
          }, 1000);
        }
      }
    }
    
    function showPinError(message) {
      pinError.textContent = message;
      pinDigits.forEach(digit => {
        digit.classList.add('error');
      });
      setTimeout(() => {
        pinDigits.forEach(digit => {
          digit.classList.remove('error');
        });
      }, 500);
    }
    
    function clearPinError() {
      pinError.textContent = '';
      pinDigits.forEach(digit => {
        digit.classList.remove('error');
      });
    }
    
    function clearPinInputs() {
      pinDigits.forEach(digit => {
        digit.value = '';
        digit.classList.remove('filled');
      });
    }
    
    function hidePinOverlay() {
      pinOverlay.classList.add('hidden');
    }
    
    // CSV Data Loading Functions
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      let i = 0;
      
      while (i < line.length) {
        const char = line[i];
        
        if (char === '"') {
          if (inQuotes && line[i + 1] === '"') {
            // Escaped quote
            current += '"';
            i += 2;
          } else {
            // Toggle quote state
            inQuotes = !inQuotes;
            i++;
          }
        } else if (char === ',' && !inQuotes) {
          // End of field
          result.push(current.trim());
          current = '';
          i++;
        } else {
          current += char;
          i++;
        }
      }
      
      // Add the last field
      result.push(current.trim());
      return result;
    }

    // Optimized CSV parsing with better memory management
    async function getSongsFromCSV() {
      try {
        console.log('Fetching CSV from Google Sheets...');
        const response = await fetch(getUrl('c1'));
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const csvText = await response.text();
        console.log('CSV text length:', csvText.length);
        
        // Cache the CSV data for offline use
        if ('caches' in window) {
          try {
            const cache = await caches.open('rhythm-csv-data');
            const csvResponse = new Response(csvText, {
              headers: { 'Content-Type': 'text/csv' }
            });
            await cache.put('csv-songs-data', csvResponse);
            console.log('CSV data cached for offline use');
          } catch (cacheError) {
            console.warn('Failed to cache CSV data:', cacheError);
          }
        }
        
        // Optimized CSV parsing with streaming approach for large files
        return parseCSVOptimized(csvText);
        
      } catch (error) {
        console.error('Error fetching CSV:', error);
        return await loadFromCache();
      }
    }

    // Optimized CSV parser with better performance
    function parseCSVOptimized(csvText) {
      const rows = [];
      const songMap = new Map();
      let currentRow = [];
      let currentField = '';
      let inQuotes = false;
      let rowCount = 0;
      
      // Process in chunks to avoid blocking the main thread
      const processChunk = (startIndex, endIndex) => {
        for (let i = startIndex; i < endIndex && i < csvText.length; i++) {
          const char = csvText[i];
          const nextChar = i + 1 < csvText.length ? csvText[i + 1] : null;
          
          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              currentField += '"';
              i++; // Skip next quote
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            currentRow.push(currentField);
            currentField = '';
          } else if ((char === '\n' || char === '\r') && !inQuotes) {
            if (currentField || currentRow.length > 0) {
              currentRow.push(currentField);
              if (currentRow.length > 0) {
                rows.push([...currentRow]); // Create copy to avoid reference issues
              }
              currentRow.length = 0; // Clear array efficiently
              currentField = '';
              rowCount++;
            }
            // Skip \r\n combinations
            if (char === '\r' && nextChar === '\n') {
              i++; // Skip \n
            }
          } else {
            currentField += char;
          }
        }
      };
      
      // Process the entire text (for small files, chunking isn't necessary)
      processChunk(0, csvText.length);
      
      // Add the last row if it exists
      if (currentField || currentRow.length > 0) {
        currentRow.push(currentField);
        if (currentRow.length > 0) {
          rows.push(currentRow);
        }
      }
      
      console.log('Parsed rows:', rows.length);
      
      // Process data rows with deduplication
      for (let i = 1; i < rows.length; i++) { // Skip header row
        const columns = rows[i];
        if (columns.length >= 5) { // Ensure we have all required columns
          const timestamp = columns[0]?.trim() || '';
          const id = parseInt(columns[1]?.trim() || '0', 10);
          const name = columns[2]?.trim() || '';
          const genre = columns[3]?.trim() || '';
          const lyrics = columns[4]?.trim() || '';
          
          if (!isNaN(id) && name && genre && lyrics) {
            const song = { id, timestamp, name, genre, lyrics };
            
            // Keep only the most recent version of each song (by ID)
            const existing = songMap.get(id);
            if (!existing || new Date(timestamp) > new Date(existing.timestamp)) {
              songMap.set(id, song);
            }
          }
        }
      }
      
      const result = Array.from(songMap.values()).sort((a, b) => a.name.localeCompare(b.name));
      console.log('Final songs array:', result.length, 'songs');
      return result;
    }

    // Optimized cache loading
    async function loadFromCache() {
      if (!('caches' in window)) return [];
      
      try {
        const cache = await caches.open('rhythm-csv-data');
        const cachedResponse = await cache.match('csv-songs-data');
        
        if (cachedResponse) {
          console.log('Loading CSV data from cache (offline mode)');
          const csvText = await cachedResponse.text();
          return parseCSVOptimized(csvText);
        }
      } catch (cacheError) {
        console.error('Error loading from cache:', cacheError);
      }
      
      return [];
    }

    // Load latest showlist from CSV
    async function loadLatestShowlist() {
      try {
        // First, get the latest showlist
        const showlistResponse = await fetch(getUrl('c2'));
        const showlistCsv = await showlistResponse.text();
        
        // Parse the showlist CSV
        const showlistRows = parseCSV(showlistCsv);
        if (showlistRows.length <= 1) {
          window.currentShowList = [];
          return; // No data beyond headers
        }
        
        // Get the latest entry (last row)
        const latestRow = showlistRows[showlistRows.length - 1];
        const latestUID = latestRow[1]; // UID is in column 2 (index 1)
        const latestShowList = latestRow[2]; // Showlist is in column 3 (index 2)
        const latestShowName = latestRow[3]; // Show Name is in column 4 (index 3)
        
        // Check if this showlist is cancelled
        const cancelResponse = await fetch(getUrl('c3'));
        const cancelCsv = await cancelResponse.text();
        
        // Parse the cancel CSV
        const cancelRows = parseCSV(cancelCsv);
        const isCancelled = cancelRows.some(row => 
          row[1] === latestUID && row[2] && row[2].toLowerCase() === 'yes' // Adjusted column indices
        );
        
        if (!isCancelled && latestShowList) {
          // Parse the showlist (assuming it's newline-separated song names)
          window.currentShowList = latestShowList.split('\n').map(song => song.trim()).filter(song => song);
          console.log('Loaded showlist with', window.currentShowList.length, 'songs');
        } else {
          window.currentShowList = [];
          // If current filter is showlist but showlist is cancelled/empty, switch to 'all'
          if (currentGenreFilter === 'showlist') {
            currentGenreFilter = 'all';
            localStorage.setItem('songListFilter', currentGenreFilter);
          }
        }
        
      } catch (error) {
        console.error('Failed to load latest showlist:', error);
        window.currentShowList = [];
        // If current filter is showlist but failed to load, switch to 'all'
        if (currentGenreFilter === 'showlist') {
          currentGenreFilter = 'all';
          localStorage.setItem('songListFilter', currentGenreFilter);
        }
      }
    }

    // Parse CSV data (reused from show-list-generator)
    function parseCSV(csvText) {
      const rows = [];
      let currentRow = [];
      let currentField = '';
      let inQuotes = false;
      let i = 0;
      
      while (i < csvText.length) {
        const char = csvText[i];
        const nextChar = i + 1 < csvText.length ? csvText[i + 1] : null;
        
        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            currentField += '"';
            i += 2;
          } else {
            inQuotes = !inQuotes;
            i++;
          }
        } else if (char === ',' && !inQuotes) {
          currentRow.push(currentField.trim());
          currentField = '';
          i++;
        } else if ((char === '\n' || char === '\r') && !inQuotes) {
          if (currentField || currentRow.length > 0) {
            currentRow.push(currentField.trim());
            if (currentRow.length > 0) {
              rows.push(currentRow);
            }
            currentRow = [];
            currentField = '';
          }
          if (char === '\r' && nextChar === '\n') {
            i += 2;
          } else {
            i++;
          }
        } else {
          currentField += char;
          i++;
        }
      }
      
      if (currentField || currentRow.length > 0) {
        currentRow.push(currentField.trim());
        if (currentRow.length > 0) {
          rows.push(currentRow);
        }
      }
      
      return rows;
    }
    
    function loadSongsData() {
      // Only load songs after PIN is verified
      if (!pinAuthenticated) {
        console.log('PIN not authenticated - blocking song data load');
        return;
      }
      
      // Show loading state
      showLoadingState();
      
      // Load CSV data and showlist in parallel with timeout
      const loadTimeout = setTimeout(() => {
        console.warn('Loading timeout - proceeding with cached data');
      }, 10000); // 10 second timeout
      
      Promise.all([
        getSongsFromCSV(),
        loadLatestShowlist()
      ])
        .then(([csvSongs]) => {
          clearTimeout(loadTimeout);
          songs = csvSongs;
          window.songs = songs; // Make global for compatibility
          hideLoadingState();
          initializeSongList();
        })
        .catch(error => {
          clearTimeout(loadTimeout);
          console.error('Failed to load songs data:', error);
          songs = [];
          window.songs = songs;
          window.currentShowList = [];
          hideLoadingState();
          initializeSongList();
        });
    }
    
    function initializeSongList() {
      songList = document.getElementById('song-list');
      searchBox = document.getElementById('search-box');
      filterBtn = document.getElementById('filter-btn');
      filterDropdown = document.querySelector('.filter-dropdown');
      filterContent = document.getElementById('filter-content');
      
      // Restore saved filter state
      const savedFilter = localStorage.getItem('songListFilter');
      if (savedFilter) {
        currentGenreFilter = savedFilter;
      }
      
      // Set up event listeners
      filterBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        filterContent.classList.toggle('show');
      });
      
      // Close dropdown when clicking outside
      document.addEventListener('click', function() {
        filterContent.classList.remove('show');
      });
      
      // Prevent dropdown from closing when clicking inside
      filterContent.addEventListener('click', function(e) {
        e.stopPropagation();
      });
      
      // Search functionality with optimized debouncing
      const debouncedSearch = debounce((searchValue) => {
        renderList(searchValue, currentGenreFilter);
      }, 250);
      
      searchBox.addEventListener('input', function(e) {
        debouncedSearch(e.target.value);
      });
      
      // Focus search box when typing (unless in an input)
      document.addEventListener('keydown', function(e) {
        if (e.target.tagName !== 'INPUT' && e.key.match(/[a-zA-Z0-9]/)) {
          searchBox.focus();
        }
      });
      
      // Initialize UI
      updateFilterDropdown();
      renderList('', currentGenreFilter);
      
      // Restore scroll position if returning from lyrics page
      restoreScrollPosition();
    }
    
    // Optimized genre counting with caching
    function updateFilterDropdown() {
      if (!songs || songs.length === 0) {
        filterContent.innerHTML = '<a onclick="setFilter(\'all\')">All (0)</a>';
        return;
      }
      
      // Use cached counts if songs haven't changed
      if (updateFilterDropdown.cachedSongs === songs) {
        return;
      }
      
      // Count songs by genre efficiently
      const genreCounts = songs.reduce((counts, song) => {
        counts.all++;
        if (counts.hasOwnProperty(song.genre)) {
          counts[song.genre]++;
        }
        return counts;
      }, {
        all: 0,
        Baburu: 0,
        Kaasi: 0,
        Nala: 0,
        Taki: 0,
        Thinberu: 0,
        Zamaanee: 0,
        showlist: 0
      });

      // Count showlist songs
      if (window.currentShowList && window.currentShowList.length > 0) {
        genreCounts.showlist = window.currentShowList.length;
      }
      
      // Build dropdown content using template literals for better performance
      const dropdownItems = [
        `<a onclick="setFilter('all')">All (${genreCounts.all})</a>`
      ];
      
      // Only add showlist option if there's an active showlist
      if (window.currentShowList && window.currentShowList.length > 0) {
        dropdownItems.push(`<a onclick="setFilter('showlist')">Show List (${genreCounts.showlist})</a>`);
      }
      
      // Add genre filters
      ['Baburu', 'Kaasi', 'Nala', 'Taki', 'Thinberu', 'Zamaanee'].forEach(genre => {
        dropdownItems.push(`<a onclick="setFilter('${genre}')">${genre} (${genreCounts[genre]})</a>`);
      });
      
      // Update dropdown content in one operation
      filterContent.innerHTML = dropdownItems.join('');
      
      // Cache the results
      updateFilterDropdown.cachedSongs = songs;
    }

    // Optimized list rendering with virtual scrolling considerations
    function renderList(searchFilter = '', genreFilter = 'all') {
      const startTime = performance.now();
      
      if (!songs || songs.length === 0) {
        songList.innerHTML = '<li style="color: #999; cursor: default;">No songs available</li>';
        return;
      }
      
      // Pre-compile search regex for better performance
      const searchRegex = searchFilter ? new RegExp(searchFilter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i') : null;
      
      // Create showlist lookup set for O(1) lookups
      const showlistSet = genreFilter === 'showlist' && window.currentShowList 
        ? new Set(window.currentShowList) 
        : null;
      
      // Filter songs efficiently
      const filteredSongs = songs.filter(song => {
        const matchesSearch = !searchRegex || searchRegex.test(song.name);
        
        let matchesGenre;
        if (genreFilter === 'showlist') {
          matchesGenre = showlistSet && showlistSet.has(song.name);
        } else {
          matchesGenre = genreFilter === 'all' || song.genre === genreFilter;
        }
        
        return matchesSearch && matchesGenre;
      });
      
      // Use DocumentFragment for better performance
      const fragment = document.createDocumentFragment();
      
      if (filteredSongs.length === 0) {
        const li = document.createElement('li');
        li.textContent = 'No songs match your search';
        li.style.cssText = 'color: #999; cursor: default;';
        fragment.appendChild(li);
      } else {
        // Create elements efficiently
        filteredSongs.forEach(song => {
          const li = document.createElement('li');
          li.textContent = song.name;
          li.style.color = '#f5d467';
          
          // Use event delegation for better performance
          li.dataset.songId = song.id;
          
          fragment.appendChild(li);
        });
      }
      
      // Single DOM update
      songList.innerHTML = '';
      songList.appendChild(fragment);
      
      console.log(`Rendered ${filteredSongs.length} songs in ${performance.now() - startTime}ms`);
    }
    
    // Event delegation for song clicks
    document.addEventListener('click', function(e) {
      if (e.target.matches('#song-list li[data-song-id]')) {
        const songId = e.target.dataset.songId;
        
        // Save current scroll position before navigating
        localStorage.setItem('songListScrollPosition', window.pageYOffset || document.documentElement.scrollTop);
        localStorage.setItem('selectedSongId', songId);
        
        // Refresh session before navigating
        if (pinAuthenticated) {
          const sessionData = {
            timestamp: Date.now(),
            authenticated: true,
            sessionType: 'songlist'
          };
          sessionStorage.setItem('pinSession', JSON.stringify(sessionData));
        }
        
        window.location.href = 'lyrics-csv';
      }
    });

    // Global functions for onclick handlers (optimized)
    function setFilter(genre) {
      if (currentGenreFilter === genre) return; // Avoid unnecessary re-renders
      
      currentGenreFilter = genre;
      localStorage.setItem('songListFilter', genre);
      
      // Close dropdown with animation
      const filterContent = document.getElementById('filter-content');
      filterContent.classList.remove('show');
      
      // Update list
      renderList(document.getElementById('search-box').value, currentGenreFilter);
    }
    
    // Add loading state management
    function showLoadingState() {
      const songList = document.getElementById('song-list');
      songList.innerHTML = '<li style="color: #999; cursor: default; text-align: center;">Loading songs...</li>';
    }
    
    function hideLoadingState() {
      // Loading state will be replaced by actual content in renderList
    }
    
    // Optimize scroll restoration
    function restoreScrollPosition() {
      const savedScrollPosition = localStorage.getItem('songListScrollPosition');
      if (savedScrollPosition) {
        // Use requestAnimationFrame for smoother scrolling
        requestAnimationFrame(() => {
          window.scrollTo({
            top: parseInt(savedScrollPosition),
            behavior: 'auto' // Instant for better UX on return
          });
          localStorage.removeItem('songListScrollPosition');
        });
      }
    }
  </script>
</body>
</html>
